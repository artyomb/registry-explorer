ruby:
  require_relative '../utils/Node'
  require_relative '../utils/file_utils'
  margin_coef=1.5
  possible_statuses = ['error', 'ok', 'warning']

  base_path = (ENV['DBG'].nil? ? "/var/lib/registry" : Dir.pwd + '/../temp') + "/docker/registry/v2"

  path_to_repositories = base_path + "/repositories"
  repositories_path_list = Dir.glob(path_to_repositories + "/*").select { |f| File.directory?(f) }
  images = []
  images_path_list = Dir.glob("#{path_to_repositories}/**/*")
                        .select do |f|
    File.directory?(f) &&
            Dir.exist?(File.join(f, "_layers")) &&
            Dir.exist?(File.join(f, "_manifests")) &&
            Dir.exist?(File.join(f, "_uploads"))
  end
  puts("Founded following images:\n #{images_path_list}")
  puts
  images_path_list.each do |image_path|
    subfolders = image_path.split('/')
    image_name = "/" + subfolders[subfolders.find_index('repositories') + 1..].join('/')
    current_img = { name: image_name, tags: [], total_size: "-", total_layers: "-", status: "-" }
    images << current_img
    Dir.glob(image_path + "/_manifests/tags/*").select { |f| File.directory?(f) }.each do |tag_path|
      extract_tag_with_image(tag_path, base_path, image_name, current_img)
    end
  end

  tree = {children: {}, image: {} }
  # suppose images has name attribute. The name should split by '/'. Build a tree from it.
  images.each do |image|
    path_parts = image[:name].split('/')[1..]  # Skip first empty element from leading '/'
    current = tree
    path_parts.each do |part|
      current[:children][part] ||= { children: {}, image: {} }
      current = current[:children][part]
    end
    current[:image] = image
  end

  # deep flatten tree
  flatten_tree = lambda do |node, level = 0, pname = nil|
    result = []
    node[:children].each do |name, child|
      result << { name: [pname, name].flatten.compact.join('/'), level: level, image: child[:image], children_count: child[:children].size }
      result.concat(flatten_tree[child, level + 1, [pname, name]])
    end
    result
  end
  flattened = flatten_tree[tree]
sass:
  .header-container
    display: flex
    justify-content: space-between
    align-items: center
  .btns-container
    display: flex
    justify-content: space-between
    column-gap: 1rem

  .tree-node
    cursor: pointer
  .hide-show-arrow
    cursor: pointer
    transition: transform 0.3s ease
    transform: rotate(0deg)
    &.rotate-arrow
      transform: rotate(90deg)

  .tr[data-href]
    cursor: pointer
    &:hover
      background-color: rgba(115, 209, 230, 0.22)
  .hidden
    display: none

  .switch-btn
    background-color: #EDF1F9
    color: black
    &:hover
      color: white
      background-color: #4D7DD0
  .active
    color: white
    background-color: #4D7DD0
javascript:
  function showAllChildrenLevelOne(currentNode) {
    let childElem = currentNode.nextElementSibling;
    let closestArrow = currentNode?.querySelector(".hide-show-arrow");
    closestArrow?.classList.add("rotate-arrow");
    closestArrow = childElem?.querySelector(".hide-show-arrow");
    let levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
    while (childElem && levelDifference > 0) {
      if (levelDifference === 1) {
        closestArrow?.classList.remove("rotate-arrow");
        childElem.classList.remove('hidden');
      }
      childElem = childElem.nextElementSibling;
      closestArrow = childElem?.querySelector(".hide-show-arrow");
      levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
    }
  }

  function hideAllChildren(currentNode) {
    let childElem = currentNode.nextElementSibling;
    let closestArrow = currentNode?.querySelector(".hide-show-arrow");
    while (childElem && parseInt(childElem.dataset.level) > parseInt(currentNode.dataset.level)) {
      closestArrow?.classList.remove("rotate-arrow");
      childElem.classList.add('hidden');
      childElem = childElem.nextElementSibling;
      closestArrow = childElem?.querySelector(".hide-show-arrow");
    }
  }

  document.addEventListener("DOMContentLoaded", function() {
      document.querySelectorAll(".tree-node").forEach(function(treeNode) {
          if (treeNode.dataset.level <= 0) {
              treeNode.classList.remove("hidden");
              treeNode.querySelector(".hide-show-arrow")?.classList.remove("rotate-arrow");
          }
      });
      document.querySelector('body').addEventListener('click', function(event) {
          const row = event.target.closest('tr[data-href]');
          if (row) window.location.href = row.dataset.href;
          const currentNode = event.target.closest('.tree-node');
          let closestArrow = currentNode?.querySelector(".hide-show-arrow");
          if (currentNode) {
              if (!closestArrow) return;
              const branchExpanded = closestArrow.classList.contains("rotate-arrow");
              if (branchExpanded) { hideAllChildren(currentNode); }
              else { showAllChildrenLevelOne(currentNode); }
          }
      });

      document.querySelectorAll('.switch-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              const isActive = btn.classList.contains('active');
              if (!isActive) {
                  const btnText = btn.textContent;
                  if (btnText === "Tree view") {
                      document.querySelectorAll('.tree-node').forEach(elem =>{
                          if (elem.dataset.level > 0) {
                              elem.classList.add('hidden');
                              elem.querySelector('.table-view')?.classList.add('hidden');
                              elem.querySelector('.tree-view')?.classList.remove('hidden');
                              elem.querySelector('.hide-show-arrow')?.classList.add('rotate-arrow');
                          } else {
                              elem.classList.remove('hidden');
                              elem.querySelector('.hide-show-arrow')?.classList.remove('rotate-arrow'); }
                      });
                  } else {
                      document.querySelectorAll('.tree-node').forEach(elem => {
                         elem.classList.remove('hidden');
                      });
                      document.querySelectorAll('.tree-view').forEach(elem => {
                          elem.classList.add('hidden');
                      });
                      document.querySelectorAll('.table-view').forEach(elem => {
                          elem.classList.remove('hidden');
                      });
                  }
                  btn.classList.add('active');
                  if (btn.nextElementSibling) btn.nextElementSibling.classList.remove('active');
                  else btn.previousElementSibling.classList.remove('active');
              }
          });
      });
  });
.header-container
  h1 Registry
  .btns-container
    button.switch-btn.active= "Tree view"
    button.switch-btn= "Table view"
table
  tr
    th style="width: 20px"
    th style="padding: 0" Image name
    th
    th style="width: 120px" Created at
  - flattened.each do |node|
    tr.tree-node.tree-view.hidden data-level="#{node[:level]}"
      td
        - unless node[:children_count] == 0 && (node[:image][:tags] || []).empty?
          img.hide-show-arrow.rotate-arrow src='/images/chevron-right.svg' alt="Toggle Example"
      td style="padding-left: #{node[:level]}em" = node[:name]
      td
      td Created at
    - node[:image][:tags]&.each do |tag|
      tr.tree-node.hidden data-href="/tag-exploring#{node[:image][:name]}/#{tag[:name]}" data-level="#{node[:level]+1}"
        td
          span uk-icon="icon: tag"
        td
          span.tree-view style="padding-left: #{node[:level] + 1}em"
          span.table-view.hidden #{node[:image][:name][1..]}:
          span #{tag[:name]}
        td
          / #{(tag[:index_Nodes].map { |index_node| index_node[:node].created_at.nil? ? -1 : index_node[:node].created_at }).min}
        td Created at