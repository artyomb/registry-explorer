ruby:
  require_relative '../utils/Node'
  require_relative '../utils/file_utils'
  margin_coef=1.5
  possible_statuses = ['error', 'ok', 'warning']

  images = []
  unique_blobs_sizes = {}
  extract_images(images, unique_blobs_sizes)

  # TODO: implement calculation of total size of subfolders and amount of images in them
  tree = { children: {}, image: {}, total_images_amount: 0, required_blobs: Set.new, problem_blobs: [] }
  # suppose images has name attribute. The name should split by '/'. Build a tree from it.
  images.each do |image|
    path_parts = image[:name].split('/')[1..]  # Skip first empty element from leading '/'
    current = tree
    path_parts.each do |part|
      current[:total_images_amount] += 1
      current[:required_blobs].merge(image[:required_blobs])
      if image[:problem_blobs].size > 0
        current[:problem_blobs] += image[:problem_blobs]
      end
      current[:children][part] ||= { children: {}, image: {}, total_images_amount: 0, required_blobs: Set.new, problem_blobs: [] }
      current = current[:children][part]
    end
    current[:image] = image
  end

  # deep flatten tree
  flatten_tree = lambda do |node, level = 0, pname = nil|
    result = []
    node[:children].each do |name, child|
      result << { name: [pname, name].flatten.compact.join('/'), level: level, image: child[:image], children_count: child[:total_images_amount], required_blobs: child[:required_blobs], problem_blobs: child[:problem_blobs] }
      result.concat(flatten_tree[child, level + 1, [pname, name]])
    end
    result
  end
  flattened = flatten_tree[tree]

sass:
  .warning-background
    background-color: #ffa01aa6
    &:hover
      background-color: #ffa01a


javascript:
  function showAllChildrenLevelOne(currentNode) {
    let childElem = currentNode.nextElementSibling;
    let closestArrow = currentNode?.querySelector(".hide-show-arrow");
    closestArrow?.classList.add("rotate-arrow");
    closestArrow = childElem?.querySelector(".hide-show-arrow");
    let levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
    while (childElem && levelDifference > 0) {
      if (levelDifference === 1) {
        closestArrow?.classList.remove("rotate-arrow");
        childElem.classList.remove('hidden');
      }
      childElem = childElem.nextElementSibling;
      closestArrow = childElem?.querySelector(".hide-show-arrow");
      levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
    }
  }

  function showAllChildren(currentNode) {
      let childElem = currentNode.nextElementSibling;
      let closestArrow = currentNode?.querySelector(".hide-show-arrow");
      closestArrow?.classList.add("rotate-arrow");
      closestArrow = childElem?.querySelector(".hide-show-arrow");
      let levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
      while (childElem && levelDifference > 0) {
          closestArrow?.classList.add("rotate-arrow");
          childElem.classList.remove('hidden');
          childElem = childElem.nextElementSibling;
          closestArrow = childElem?.querySelector(".hide-show-arrow");
          levelDifference = parseInt(childElem.dataset.level) - parseInt(currentNode.dataset.level);
      }
  }

  function hideAllChildren(currentNode) {
    let childElem = currentNode.nextElementSibling;
    let closestArrow = currentNode?.querySelector(".hide-show-arrow");
    while (childElem && parseInt(childElem.dataset.level) > parseInt(currentNode.dataset.level)) {
      closestArrow?.classList.remove("rotate-arrow");
      childElem.classList.add('hidden');
      childElem = childElem.nextElementSibling;
      closestArrow = childElem?.querySelector(".hide-show-arrow");
    }
  }

  document.addEventListener("DOMContentLoaded", function() {
      document.querySelectorAll(".tree-node").forEach(function(treeNode) {
          if (treeNode.dataset.level <= 0) {
              treeNode.classList.remove("hidden");
              treeNode.querySelector(".hide-show-arrow")?.classList.remove("rotate-arrow");
          }
      });

      document.querySelector('body').addEventListener('click', function(event) {
          const row = event.target.closest('tr[data-href]');
          if (row) window.location.href = row.dataset.href;
          const currentNode = event.target.closest('.tree-node');
          let closestArrow = currentNode?.querySelector(".hide-show-arrow");
          if (currentNode) {
              if (!closestArrow) return;
              const branchExpanded = closestArrow.classList.contains("rotate-arrow");
              if (branchExpanded) {
                  if (event.ctrlKey) {
                      showAllChildren(currentNode);
                  } else { hideAllChildren(currentNode);}
              } else {
                  if (event.ctrlKey) {
                      showAllChildren(currentNode);
                  } else {
                      showAllChildrenLevelOne(currentNode);
                  }
              }
          }
      });

      document.querySelectorAll('.switch-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              const isActive = btn.classList.contains('uk-button-primary');
              if (!isActive) {
                  const btnText = btn.textContent;
                  if (btnText === "Tree view") {
                      document.querySelectorAll('.tree-node').forEach(elem =>{
                          if (elem.dataset.level > 0) {
                              elem.classList.add('hidden');
                              elem.querySelector('.table-view')?.classList.add('hidden');
                              elem.querySelector('.tree-view')?.classList.remove('hidden');
                              elem.querySelector('.hide-show-arrow')?.classList.add('rotate-arrow');
                          } else {
                              elem.classList.remove('hidden');
                              elem.querySelector('.hide-show-arrow')?.classList.remove('rotate-arrow'); }
                      });
                  } else {
                      document.querySelectorAll('.tree-node').forEach(elem => {
                         elem.classList.remove('hidden');
                      });
                      document.querySelectorAll('.tree-view').forEach(elem => {
                          elem.classList.add('hidden');
                      });
                      document.querySelectorAll('.table-view').forEach(elem => {
                          elem.classList.remove('hidden');
                      });
                  }
                  btn.classList.add('uk-button-primary');
                  if (btn.nextElementSibling) btn.nextElementSibling.classList.remove('uk-button-primary');
                  else btn.previousElementSibling.classList.remove('uk-button-primary');
              }
          });
      });
  });

h1.uk-h1 Registry
.uk-button-group.float-right
  button.switch-btn.uk-button.uk-button-primary style=""= "Tree view"
  button.switch-btn.uk-button.uk-button-default style=""= "Table view"
table.uk-table.uk-table-hover
  thead
    tr
      th Image/tag name
      th style="text-align: right" Images/tags amount
      th style="text-align: right" Size
      th Created at
  tbody
    - flattened.each do |node|
      tr.tree-node.tree-view.hidden data-level="#{node[:level]}"
        td
          span style="padding-left: #{node[:level]}em"
          - unless node[:children_count] == 0 && (node[:image][:tags] || []).empty?
            span.hide-show-arrow uk-icon="icon: chevron-right"
          span = node[:name]
        td.alight-text-right
        td.align-text-right #{node[:children_count] == 0 ? represent_size(node[:image][:total_size]) : represent_size(node[:required_blobs].sum { |blob| begin; size = blob_size(blob); size == -1 ? (node[:problem_blobs] << blob; 0) : size; rescue; 0; end })}
        td -
      - node[:image][:tags]&.each do |tag|
        tr.tree-node.hidden class="#{tag[:problem_blobs].size > 0 ? 'warning-background' : ''}" data-href="/tag-exploring#{node[:image][:name]}/#{tag[:name]}" data-level="#{node[:level]+1}"
          td
            - if tag[:problem_blobs].size != 0
              span uk-tooltip="title: #{(tag[:problem_blobs].size == 0) ? 'Full size of tag' : "Some layers of tag not found:<br>" + tag[:problem_blobs].map{|s| s[0..25] + '...' }.join('<br>') + " Actual size without problem blobs: " + represent_size(tag[:size])}; delay: 500;"  uk-icon="icon: warning"
            span.tree-view style="padding-left: #{node[:level] + 1}em"
            span uk-icon="icon: tag"
            span.table-view.hidden #{node[:image][:name][1..]}:
            span #{tag[:name]}
          td.align-text-right #{tag[:index_Nodes].size}
          td.align-text-right #{represent_size(tag[:size]).to_s + (tag[:problem_blobs].size > 0 ? ' (some blobs not found)' : '')}
          td #{tag[:index_Nodes].select{|nd| tag[:current_idnex_sha256] == nd[:index_sha256]}.first[:node].created_at}