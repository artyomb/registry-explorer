ruby:
  require_relative '../sinatra/sinatra_server'
  require_relative '../utils/time_measurer'
  require_relative '../utils/garbage_collection'
  require_relative '../utils/file_utils'
  require_relative '../utils/common_utils'

  session = RegistryExplorerFront.get_session
  previous_session_flag = session[:attestations_exploring]
  session[:attestations_exploring] = true
  CachesManager.execute_refresh_pipeline


  # EXPLORING BLOBS FOR FURTHER GARBAGE COLLECTION
  stored_blobs = nil
  stored_blobs_size = nil
  required_blobs = nil
  required_blobs_size = nil
  unused_blobs = nil
  unused_blobs_size = nil
  not_existing_blobs = Set.new
  blobs_set = Set.new
  images = extract_images()
  TimeMeasurer.start_measurement
  TimeMeasurer.measure(:calculate_disk_usage) do
    blobs_path = $base_path + '/blobs/sha256'
    required_blobs = images.map { _1[:required_blobs] }.reduce(Set.new, :merge)
    stored_blobs = Set.new
    Dir.children(blobs_path).each do |path|
      current_blobs = Dir.children(File.join(blobs_path, path))
      stored_blobs.merge(current_blobs)
      current_blobs.each { |blob| blobs_set.add({ "sha256" => blob, "size" => CachesManager.blob_size(blob), "is_required" => required_blobs.include?(blob) }) }
    end
    # TODO: implement exploring unnecessary blobs
    puts "Directory size: #{represent_size(Dir.glob(File.join(blobs_path, '**', '*')) # Get all files and subdirectories
                                              .select { |file| File.file?(file) } # Filter only files
                                              .sum { |file| File.size(file) })}"
    unused_blobs = stored_blobs - required_blobs
    not_existing_blobs = required_blobs - stored_blobs
    required_blobs_size = required_blobs.map { |b| CachesManager.blob_size(b) }.sum
    stored_blobs_size = stored_blobs.map { |b| CachesManager.blob_size(b) }.sum
    unused_blobs_size = unused_blobs.map { |b| CachesManager.blob_size(b) }.sum
    disk_size_tooltip = "title:" +
            "Disk usage is calculated as the sum of all blobs in the registry.<br><br>" +
            "Actual data:<br>" +
            "#{required_blobs.size} required blobs disk usage: #{represent_size(required_blobs_size)}<br>" +
            "#{stored_blobs.size} stored blobs disk usage: #{represent_size(stored_blobs_size)}<br>" +
            "#{unused_blobs.size} unused blobs disk usage: #{represent_size(unused_blobs_size)}<br>" +
            "#{not_existing_blobs.size} not existing blobs"
  end
  TimeMeasurer.log_measurers

  # MAIN PART WITH REVISONS STATS
  images_paths = get_images_paths

  #all_revisions_set = Set.new
  #unlinked_revisions_set = Set.new
  #linked_and_unused_revisions_set = Set.new

  # Exploring each revisions directory (suggestion: even if blob is unused in any tag index, it still can be used in other revisions despite they are not referenced)

  revisions_no_link_has_blob = Set.new
  revisions_no_link_no_blob = Set.new
  revisions_linked_has_blob = Set.new
  revisions_linked_no_blob = Set.new
  images_paths.each do |image_path|
    revisions_paths = Dir.children(File.join(image_path, '_manifests', 'revisions', 'sha256'))
    revisions_paths.each do |revision_path|
      # Check revisions without link
      if !File.exist?(File.join(image_path, '_manifests', 'revisions', 'sha256', revision_path, 'link'))
        if stored_blobs.include?(revision_path)
          revisions_no_link_has_blob.add(revision_path)
        else
          revisions_no_link_no_blob.add(revision_path)
        end
      else
        if stored_blobs.include?(revision_path)
          revisions_linked_has_blob.add(revision_path)
        else
          revisions_linked_no_blob.add(revision_path)
        end
      end
    end
  end
  garbage_collect_candidates_nodes = []
  revisions_no_link_has_blob.each do |revision_path|
    garbage_collect_candidates_nodes << CachesManager.get_node(nil, revision_path)
  end
  all_blobs_from_garbage_collect_candidates = Set.new
  garbage_collect_candidates_nodes.each do |node|
    all_blobs_from_garbage_collect_candidates.merge(node.get_included_blobs)
  end
  all_unused_garbage_collect_candidate_blobs = all_blobs_from_garbage_collect_candidates.select { |b| unused_blobs.include?(b) }
  revisions_linked_has_blob_nodes = []
  revisions_linked_has_blob.each do |revision_path|
    revisions_linked_has_blob_nodes << CachesManager.get_node(nil, revision_path)
  end
  all_blobs_from_revisions_linked_has_blob = Set.new
  revisions_linked_has_blob_nodes.each do |node|
    all_blobs_from_revisions_linked_has_blob.merge(node.get_included_blobs)
  end
  unused_revisions = Set.new
  revisions_linked_has_blob.each do |revision_path|
    unused_revisions.add(revision_path) if unused_blobs.include?(revision_path)
  end
  unused_revisions_nodes = []
  unused_revisions.each do |revision_path|
    unused_revisions_nodes << CachesManager.get_node(nil, revision_path)
  end
  unused_revisions_blobs = Set.new
  unused_revisions_nodes.each do |node|
    unused_revisions_blobs.merge(node.get_included_blobs)
  end

  actually_unused_blobs = unused_revisions_blobs.select { |b| unused_blobs.include?(b) }
  if actually_unused_blobs.select { |b| unused_revisions.include?(b) }.size != unused_revisions.size
    raise "Not all unused revisions have unused blobs"
  end
  actually_unused_blobs_size = 0
  actually_unused_blobs.each do |blob|
    actually_unused_blobs_size += CachesManager.blob_size(blob)
  end
  ####################################################################################################################################
  all_revisions_set = get_all_revisions_set(revisions_linked_no_blob, revisions_linked_has_blob, revisions_no_link_no_blob, revisions_no_link_has_blob)
  all_revisions_nodes = []
  all_revisions_blobs = Set.new
  all_revisions_blobs_total_size = 0
  all_revisions_set.each do |revision_path|
    all_revisions_nodes << CachesManager.get_node(nil, revision_path)
    all_revisions_blobs.merge(CachesManager.get_node(nil, revision_path).get_included_blobs)
  end
  all_revisions_blobs_total_size = all_revisions_blobs.map { |b| CachesManager.blob_size(b) }.sum
  #####################################################################################################################################
  images_structure = get_images_strictire_where_indexes_without_revisions # retirns images structure with tags and indexes, where indexes are without link in revisions
  revisions_nodes_from_indexes_without_link = images_structure.flat_map{|img| img[:tags].flat_map { |tag| tag[:index_Nodes] } }.flatten
  revisions_nodes_from_indexes_without_link_blobs = Set.new
  images_structure.each{ |img| revisions_nodes_from_indexes_without_link_blobs.merge(img[:required_blobs]) }
  revisions_nodes_from_indexes_without_link_blobs_total_size = revisions_nodes_from_indexes_without_link_blobs.map { |b| CachesManager.blob_size(b) }.sum
  ####################################################################################################################################
  affected_images_structure = get_images_structure_affected_by_gc(Set.new, unused_blobs)
  ####################################################################################################################################
  linked_index_nodes = []
  images.map { |img| img[:tags].each { |tag| linked_index_nodes << tag[:index_Nodes] } }
  session[:attestations_exploring] = previous_session_flag

sass:
  .copy-btn
    margin-left: 3.5rem

  .inline-container-small
    display: inline-block
    width: 3rem

  .inline-container
    display: inline-block
    width: 5rem

.uk-flex.uk-flex-row.align-items-center.uk-padding.uk-padding-remove-horizontal
  a.uk-link-text.border-around.hover-darker.padding-xsmall.uk-width-fit-content.uk-margin-right.align-content-center.uk-text-center href = "/blobs-exploring"
    span.icon-padding-right.icon-padding-left.uk-text-primary uk-icon = "icon: chevron-left"
  .uk-flex.uk-width-expand.uk-flex-between.align-items-center
    h1.uk-h1.uk-margin-remove-bottom = " #{ 'Garbage collection review' }"
p
  span In registry exist
  span.uk-text-italic.uk-text-bold= " #{stored_blobs.size} "
  span blobs, which use
  span.uk-text-italic.uk-text-bold= " #{represent_size(stored_blobs_size)} "
  span disk space
  br
  span Unused
  span.uk-text-italic.uk-text-bold= " #{unused_blobs.size} "
  span blobs, which use
  span.uk-text-italic.uk-text-bold= " #{represent_size(unused_blobs_size)} "
  span disk space, which will be removed from all images
/ p= "Following images will be affected after confirmation of garbage collection:"
/ ul
/   - affected_images_structure.each do |image|
/     li
/       span.uk-text-italic.uk-text-bold= image[:name]
/       span  has
/       span.uk-text-italic.uk-text-bold #{image[:tags].size}
/       span  unreferenced tags;
/       span.uk-text-italic.uk-text-bold= " #{image[:revisions].size} "
/       span unused revisions;
/       span.uk-text-italic.uk-text-bold= " #{image[:layers].size} "
/       span unused layers.
table.uk-table.uk-table-hover.uk-table-divider.uk-table-striped id="blobs-table"
  thead
    tr
      th.align-text-center style="min-width: 3%; width: 3%; max-width: 3%"
        / span Filter
        span.icon-padding-left.uk-text-primary.cursor-pointer  uk-icon="icon: menu" onclick="event.stopPropagation(); document.getElementById('include-menu').classList.toggle('uk-hidden')"
      th style="min-width: 25%; width: 25%; max-width: 25%" Image name
      th.uk-float-right Unreferenced indexes
      th.align-text-right Unused revision
      th.uk-text-right Unused layers
  tbody
    tr
      td
      td.uk-text-italic.uk-text-bold Total
      td.uk-text-italic.uk-text-bold.align-text-right= affected_images_structure.map{|i| i[:tags].size}.sum
      td.uk-text-italic.uk-text-bold.align-text-right= affected_images_structure.map{|i| i[:revisions].size}.sum
      td.uk-text-italic.uk-text-bold.align-text-right= affected_images_structure.map{|i| i[:layers].size}.sum
    - affected_images_structure.each do |image|
      tr
        td
        td.uk-text-italic.uk-text-bold= image[:name]
        td.uk-text-italic.uk-text-bold.align-text-right= image[:tags].size
        td.uk-text-italic.uk-text-bold.align-text-right= image[:revisions].size
        td.uk-text-italic.uk-text-bold.align-text-right= image[:layers].size

